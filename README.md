# 프로세스와 스레드

### 프로세스란
- 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 상태
- 운영체제로부터 
    - 함수의 매개변수, 복귀주소와 로컬 변수와 같은 임시적인 자료를 가지는 프로세스 스택
    - 전역 변수들을 수록하는 데이터 섹션
    - 프로세스 실행 중 동적으로 할당되는 힙
- 실행 파일이 메모리에 적재될 때 프로세스가 됨

### 프로세스 제어 블록 (PCB, Process Control Block)
- 각 프로세스는 프로세스 제어 블록에 의해 표현된다
- PCB는 특정 프로세스에 대한 중요한 정보를 나타내는 운영체제의 자료구조
- 단순하게, 프로세스마다 달라지는 모든 정보 저장하며 프로세스의 생성과 동시에 고유한 PCB가 생성됨.
- 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고, CPU를 반환하는데 이 때 작업의 진행 상황을 모두 PCB에 저장

- PCB에 저장되는 정보
    - 프로세스 식별번호(PID, Process ID)
    - 프로세스 상태 : new, ready, running, waiting, halted 상태 등..
    - 프로그램 카운터 : 해당 프로세스 다음에 실행할 명령어의 주소
    - CPU 레지스터들 : 컴퓨터의 구조에 따라 다양한 수와 타입을 가짐
    - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터
    - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 포함
    - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
    - 어카운팅 정보 : 사용된 PCU시간, 경과된 시간 등..
    
### 스레드란 (Thread)
- 한 프로세스 내에서 동작되는 여러 실행 흐름
- 프로세스 내의 주소 공간이나 자원 공유 가능
- 스레드 구성
    - 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택

- **스택을 스레드마다 독립적으로 할당하는 이유**
    - 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소 값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간으로 스택 메모리 공간이 독립적이여야 독립적인 함수 호출이 가능

- **PC Register를 스레드마다 독립적으로 할당하는 이유**
    - PC값은 스레드가 명령어의 어디까지 수행하였는지를 나타냄
    - 스레드는 CPU를 할당 받았다가 스케쥴러에 의해 잠시 뻇긴다. 
    - 추후에 어느 부분부터 수행해야 하는지 기억을 위해 독립적으로 할당

### 멀티스레드 vs 멀티 프로세스
- 멀티 프로세스는 프로세스간 공유하는 자원이 없기에 동일한 자원에 동시에 접근하는 일이 없음
- 멀티 스레드로 작업시에는 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 동기화 작업 필요

- 멀티스레드의 장점
    - 멀티 스레드는 멀티 프로세스보다 문맥 전환(context switch)이 빠르다
        - 스레드의 Context switch는 프로세스 Context switch와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다
    - 멀티 프로세스보다 많은 메모리 공간과 CPU시간 차지한다
    - 스레드 간의 통신시 별도의 자원을 이용하는 것이 아닌 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap영역을 이용하여 데이터를 주고받는다.
- 멀티스레드의 단점
    - 오류로 인해 스레드 하나가 종료시 전체 스레드가 종료될 수 있다
    - 동기화를 통한 작업 처리 순서 컨트롤 및 공유 자원에 대한 접근 컨트롤 (병목현상 발생으로 인한 성능저하)
    
    
## 문맥교환(Context Switch)
- 인터럽트 발생시 운영체제가 CPU를 현재 작업에서 빼앗아 커널 루틴에서 실행할 수 있게 함
- 인터럽트 종료 후 과거 처리하던 문맥을 복구할 수 있도록 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요
- 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구함

## CPU 스케줄러

### FCFS(First Come First Served)
- 즉 먼저 온 순서대로 처리 / 비선점형(Non-Preemptive) 스케줄링
- 일단 CPU 를 잡으면 CPU burst 가 완료될 때까지 CPU 를 반환하지 않는다. 할당되었던 CPU 가 반환될 때만 스케줄링이 이루어진다.
- 문제점
    - convoy effect / 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.

### SJF(Shortest - Job - First)
- 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
- 비선점형(Non-Preemptive) 스케줄링
- 문제점
    - starvation / 이 스케줄링은 극단적으로 CPU 사용이 짧은 job 을 선호 / 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없음

### SRT(Shortest Remaining time First)
- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다. / 선점형 (Preemptive) 스케줄링
- 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가진 새로운 프로세스가 도착하면 CPU 를 뺏김
- 문제점
    - starvation / 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

### Priority Scheduling
- 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링 
- 선점형 스케줄링(Preemptive) 방식
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
- 비선점형 스케줄링(Non-Preemptive) 방식
    - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.
- 문제점
    - starvation / 무기한 봉쇄(Indefinite blocking) / 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태

### Round Robin
- 현대적인 CPU 스케줄링 / 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
- RR은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- RR이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.
- 장점
    - Response time이 빨라진다.
    - n 개의 프로세스가 ready queue 에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
    - 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가한다.
    - 공정한 스케줄링이라고 할 수 있다.
